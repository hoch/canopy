<html>
<head>
  <title>Canopy &#9835;</title>
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  
  <script src="bower_components/webcomponentsjs/webcomponents.js"></script>
  <link rel="import" href="bower_components/core-toolbar/core-toolbar.html">
  <link rel="import" href="bower_components/core-menu/core-menu.html">
  <link rel="import" href="bower_components/core-item/core-item.html">
  <link rel="import" href="bower_components/core-header-panel/core-header-panel.html">
  <link rel="import" href="bower_components/core-drawer-panel/core-drawer-panel.html">
  <link rel="import" href="bower_components/core-scaffold/core-scaffold.html">

  <link href="bower_components/font-roboto/roboto.html" rel="import">
  <link href="bower_components/core-icon/core-icon.html" rel="import">
  <link href="bower_components/core-icons/core-icons.html" rel="import">
  <link href="bower_components/paper-button/paper-button.html" rel="import">

  <script src="codemirror/lib/codemirror.js"></script>
  <link rel="stylesheet" href="codemirror/lib/codemirror.css">
  <script src="codemirror/mode/javascript/javascript.js"></script>

  <script src="js/fft.js"></script>
  <script src="js/events.js"></script>

  <style>

    html, body {
      height: 100%;
      margin: 0;
    }
  
    body {
      font-family: RobotoDraft, 'Helvetica Neue', Helvetica, Arial;
      font-size: 14px;
      margin: 0;
      -webkit-tap-highlight-color: rgba(0,0,0,0);
      -webkit-touch-callout: none;
    }
    
    .content {
      background-color: #fff;
      height: 5000px;
      padding: 20px;
    }

    paper-button.colored {
      color: #4285f4;
    }

    paper-button[raised].colored {
      background: #3e50b4;
      color: #fff;
    }

    paper-button.custom > core-icon {
      margin-right: 4px;
    }

    paper-button.hover:hover {
      background: #eee;
    }

    paper-button.blue-ripple::shadow #ripple {
      color: #4285f4;
    }
        
  </style>
  
</head>

<body fullbleed layout horizontal>

  <core-header-panel style="width: 500px;">
    <core-toolbar style="background-color: #607D8B; color: #ECEFF1;">
      <core-icon-button icon="menu"></core-icon-button>
      <span flex>Canopy &#9835;</span>
      <core-icon-button icon="send" onclick="executeCode();"></core-icon-button>
    </core-toolbar>
    <div vertical layout>
      <div id="i-editor" flex></div>
      <div id="i-editor-console" style="background-color:#fee; height:200px">2</div>
    </div>
  </core-header-panel>
    
  <core-header-panel flex>
    <core-toolbar style="background-color: #546E7A;">
      
    </core-toolbar>
    <div vertical layout flex>
      <div id="i-viewer" flex>
        <canvas id="i-waveform-a"></canvas>
        <canvas id="i-specgram-a"></canvas>
      </div>
      <div id="i-viewer-info" style="height:400px"></div>
    </div>
  </core-header-panel>

  <script>
    var editorDOM = document.querySelector('#i-editor');
    var consoleDOM = document.querySelector('#i-editor-console');
    var waveformDOM = document.querySelector('#i-waveform-a');
    var spectrogramDOM = document.querySelector('#i-specgram-a');

    var context2D = waveformDOM.getContext('2d');
    context2D.canvas.width = 1200;
    context2D.canvas.height = 300;

    var contextRT = new AudioContext();

    var lastRenderedChannelData = null;
    var spectrogramData = null;
    
    var zoomLevel = 0;
    var sampleHopSize = 1;
    var xInterval = 1;
    var sampleIndexOffset = 0;


    /**
     * Render waveform view based on parameters.
     * @param  {Object} ctx 2D rendering context.
     * @param  {Float32Array} channelData AudioBuffer channel data.
     * @param  {Number} startPosition Start position in sample (integer).
     * @param  {Number} hopSize Sample hop size.
     * @param  {Number} interval Rendering interval on X-axis.
     * @param  {Number} viewWidth View width.
     * @param  {Number} viewHeight View Height.
     */
    function renderView(ctx, channelData, startPosition, hopSize, interval, viewWidth, viewHeight) {
      ctx.clearRect(0, 0, viewWidth, viewHeight);

      var index = startPosition;
      var length = channelData.length;
      var y_length, y_offset;
      
      ctx.strokeStyle = "#03A9F4";
      ctx.fillStyle = "#03A9F4";
      ctx.lineWidth = 1.0;
      ctx.beginPath();

      // When the zoom level is above 'sample-level', use simple rendering 
      // for optimum performance.
      if (interval === 1) {
        for (var x = 0; x < viewWidth; x++) {
          if (index < length) {
            y_length = Math.abs(channelData[index]) * viewHeight;
          } else {
            y_length = 0.0;
          }
          y_offset = (viewHeight - y_length) * 0.5;
          ctx.moveTo(x, y_offset);
          ctx.lineTo(x, y_offset + y_length);
          index += hopSize;
        }

      } else {

        // If the zoom level is below sample-level, use linear-interpolation 
        // (line drawing) between samples.
        var numSamples = Math.min(viewWidth, (channelData.length - startPosition) / interval);
        var x_offset = 0;
        for (i = 0; i < numSamples; i++) {
          if (index < length) {
            y_offset = channelData[startPosition + i] * 0.5 + 0.5;
          } else {
            y_offset = 0.5;
          }
          y_offset *= viewHeight;
          ctx.lineTo(x_offset, y_offset);
          ctx.fillRect(x_offset - 1, y_offset - 1, 3, 3);
          x_offset += interval;
        }
      }

      ctx.stroke();
    }

    function renderRuler(ctx, startPosition, hopSize, interval, viewWidth) {



      ctx.fillStyle = "#263238";
      ctx.strokeStyle = "#ECEFF1";
      ctx.lineWidth = 1.0;
      
      ctx.fillRect(0, 0, viewWidth, 30);
      
      console.log(startPosition);
      
      ctx.beginPath();

      // When the zoom level is above 'sample-level', use simple rendering 
      // for optimum performance.
      if (interval === 1) {
        for (var x = 0; x < viewWidth; x++) {
          // if (index % 1024 === 0) {
          //   ctx.moveTo(x, 10);
          //   ctx.lineTo(x, 28.5);
          // } else if (index % 128 === 0) {
          //   ctx.moveTo(x, 20);
          //   ctx.lineTo(x, 28.5);
          // }
          // index += hopSize;
        }

      } else {

        // If the zoom level is below sample-level, use linear-interpolation 
        // (line drawing) between samples.
        var numSamples = Math.min(viewWidth, (channelData.length - startPosition) / interval);
        var x_offset = 0;
        for (i = 0; i < numSamples; i++) {
          if (index < length) {
            y_offset = channelData[startPosition + i] * 0.5 + 0.5;
          } else {
            y_offset = 0.5;
          }
          y_offset *= viewHeight;
          ctx.lineTo(x_offset, y_offset);
          ctx.fillRect(x_offset - 1, y_offset - 1, 3, 3);
          x_offset += interval;
        }
      }

      ctx.stroke();

      
      // var index = startPosition;
      
      // ctx.beginPath();
      // for (var x = 0; x < viewWidth; x++) {
      //   var y_length = 0;
      //   if (index % 1000 === 0) {
      //     y_length = 20;
      //   } else if (index % 250 === 0) {
      //     y_length = 10;
      //   }
      //   if (y_length !== 0) {
      //     ctx.moveTo(x, 0);
      //     ctx.lineTo(x, y_length);  
      //   }
      //   index = Math.round(index + 1.0 / zoomFactor);
      // }
      // ctx.stroke();
      
    }

    var hanning = createHanningWindow(256);
    var blackman = createBlackmanWindow(256);
    var fft = new RFFT(256, 44100);

    function renderSpectrogram(canvasID, data) {
      var contextSpec = spectrogramDOM.getContext('2d');
      var width = 1200;
      var height = 300;
      spectrogramDOM.width = width;
      spectrogramDOM.height = height;
      contextSpec.strokeStyle = 'blue';
      contextSpec.clearRect(0, 0, width, height);
      

      var frame = data.subarray(0, 128);
      console.log(frame);

      fft.forward(frame);

      for (var i = 0; i < fft.spectrum.length/2; i++) {
        var magnitude = fft.spectrum[i];
        // console.log(magnitude);
        contextSpec.fillStyle = 'rgba(0, 0, 0, ' + magnitude + ')';
        contextSpec.fillRect(0, i * 5, 5, 5);
      }

      
      // for (var frame = 0; frame < 2; frame++) {

      //   console.log('frame = ' + frame);

      //   console.log('= signal =');

      //   spectrogramData.map(function (value, i, n) {
      //     // value.real = hanning[i] * lastRenderedChannelData[frame * 128 + i];
      //     // value.real = blackman[i] * lastRenderedChannelData[frame * 128 + i];
      //     value.real = lastRenderedChannelData[frame * 128 + i];
      //     console.log(value.real);
      //   });
        
      //   spectrogramData.FFT();

      //   var nyquist = spectrogramData.real.length * 0.5;
      //   var real = spectrogramData.real;
      //   var imag = spectrogramData.imag;

      //   console.log('= real =');

      //   for (var i = 0; i < spectrogramData.real.length; i++) {
      //     console.log(spectrogramData.real[i]);
      //   }

      //   console.log('= imag =');

      //   for (var i = 0; i < spectrogramData.imag.length; i++) {
      //     console.log(spectrogramData.imag[i]);
      //   }

      //   imag[0] = 0.0; // To blow above the nyquist.
      //   var magScale = 1.0 / 256;
      //   var minDecibel = -120;
        
      //   for (var i = 0; i < nyquist; i++) {
      //     var value = Math.sqrt(real[i] * real[i] + imag[i] * imag[i]) * magScale;
      //     var db = Math.max(minDecibel, 20 * Math.log10(value));
      //     db = 1.0 + (db * 0.01);
      //     db = Math.min(1.0, Math.max(0.0, db));
      //     // console.log(db);
      //     contextSpec.fillStyle = 'rgba(0, 0, 0, ' + db + ')';
      //     contextSpec.fillRect(frame * 5, i * 5, 5, 5);
      //   }

      // }
    }

    function render(ctx, channelData, startPosition, hopSize, interval, viewWidth, viewHeight) {
      renderView(ctx, channelData, startPosition, hopSize, interval, viewWidth, viewHeight);
      renderRuler(ctx, startPosition, hopSize, interval, viewWidth);
    }

    function updateView() {
      render(context2D, 
        lastRenderedChannelData, 
        sampleIndexOffset, 
        Math.max(1, sampleHopSize), 
        Math.max(1, xInterval), 
        context2D.canvas.width, 
        context2D.canvas.height);
    }

    function zoom(delta) {
      // Scroll down, zoom in.
      if (delta < 0) {
        xInterval *= 2.0;
        sampleHopSize *= 0.5;
      } else if (delta > 0) {
        // Scroll up, zoom out.
        xInterval *= 0.5;
        sampleHopSize *= 2.0;
      }
      updateView();
    }

    function pan(deltaX) {
      sampleIndexOffset += (deltaX * Math.max(1, sampleHopSize));
      sampleIndexOffset = Math.max(0, sampleIndexOffset);
      updateView();
    }

    var prevX = 0, dX = 0;

    var mouseHandler = new MouseResponder('waveform', waveformDOM, 
      function (sender, action, data) {
        // console.log(action, data);
        switch (action) {
          case 'clicked':
            prevX = data.x;
            deltaX = 0;
            break;
          case 'dragged':
            dX = prevX - data.x;
            pan(dX);
            prevX = data.x;
            break;
          case 'wheelmoved':
            // console.log(data.wheelDelta);
            zoom(data.wheelDelta);
            break;
        }
      }
    );


    function sampleCode() {
// Edit the code below and 'Run' it.
// var osc1 = context.createOscillator();
// var modGain = context.createGain();
// var osc2 = context.createOscillator();
// osc1.connect(modGain);
// modGain.connect(osc2.frequency);
// osc2.connect(context.destination);
// osc1.frequency.value = 33;
// modGain.gain.value = 3735;
// osc2.frequency.value = 77;
// osc1.start();
// osc2.start();
var osc1 = context.createOscillator();
osc1.frequency.value = 1000;
osc1.connect(context.destination);
osc1.start();
}

    var myCodeMirror = CodeMirror(editorDOM, {
      value: sampleCode.toString().slice(24, -1),
      mode: 'javascript'
    });

    

    function executeCode() {
      spawnTask(myCodeMirror.getValue());
    }
  </script>

</body>
</html>